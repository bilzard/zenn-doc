---
title: "論文解説: Glow: 可逆1x1ConvによるFlowベースの生成モデル"
emoji: "🌈"
type: "idea"
topics:
  - "論文解説"
  - "画像生成モデル"
published: true
published_at: "2022-08-03 20:13"
---

# 論文

[Glow: Generative Flow with Invertible 1x1 Convolutions](https://arxiv.org/abs/1807.03039)

# 概要

Flowベースの生成モデルとして、可逆1x1 Convによる生成モデルを提案する。提案モデルは標準的なベンチマークにおける対数尤度評価で改善を記録した。また、目的関数を対数尤度とする提案手法は大きな画像の生成タスクにてリアルな画像を効率的に生成できることを示した。

# 研究の位置付け

近年の成功をおさめた生成モデルには、対数尤度ベースのものとGANによるものである。対数尤度ベースの手法には1) 自己回帰モデル, 2) 変分エンコーダ(VAE), 3) Flowベースの生成モデルの3つがあるが、提案手法は3番目のグループに属する。

# 評価方法

6つの典型的なベンチマークによって対数尤度を評価した。いずれにおいても既存手法であるRealNVPを凌駕した（図1）。また、生成された顔画像はGANに匹敵するほど十分リアルなものだった（図2）。また、2つ顔画像の線形補完（図3）やセマンティックな編集（図4）においても意味のある画像を生成した。

**図1: 対数尤度の評価結果**
![](https://storage.googleapis.com/zenn-user-upload/86db055f8a63-20220803.png)

**図2: 提案モデルが生成した顔画像**
![](https://storage.googleapis.com/zenn-user-upload/9867b4b37c28-20220803.png)

**図3: 顔画像の線形補完**
![](https://storage.googleapis.com/zenn-user-upload/647b152ebddb-20220803.png)

**図4: セマンティックな編集**
![](https://storage.googleapis.com/zenn-user-upload/55ecbd50f4d2-20220803.png)

# 所感

* 各レイヤの計算を可逆にすることで、Forward pathのみ用意すれば順方向の変換と逆変換を両方計算できるというアイデアが秀逸
* 1x1convレイヤはパラメータの初期化時は可逆になることが保証されるが、学習時にパラメータ更新後も可逆になるかどうかは保証されないのでは？

# 付録: 背景についての補足

## Flowベースの生成モデルの特徴

Flowベースの生成モデルは自己回帰モデル、VAEやGANと比較して以下のメリットがある。

1. 潜在変数と対数尤度の推定を厳密にすることができる。VAEは対数尤度の下限を計算する近似手法であるし、GANは潜在変数を推定するネットワークを持たない。
2. 効率的な学習と生成。PixelCNNのような自己回帰モデルは並列処理が困難である。これに対し、Flowベースの手法は学習、生成時ともに並列化が可能である。
3. 潜在空間の情報を下位タスクに利用できる。データ点どうしの補完やデータ点の意味的な編集が可能である。
4. メモリ消費の大幅な節約。可逆なニューラルネットワークはメモリ消費が深さ方向に対して定数コストであることが知られている。

## Flowベース手法の概要

データセット$\mathcal{D}$に対して、パラメータ$\theta$とする確率モデル$p_{\theta}(x)$の対数尤度は以下の式で計算される。ここで、$x$はデータセット内の各サンプル（例：画像など）を表す。

$$\mathcal{L}(\mathcal{D})=\frac{1}{N}\sum_{i=1}^{N}-\log p_{\theta}(x^{(i)}) \tag{1}$$

一般的なFlowベースの手法において、生成モデルとは、潜在変数$z$からデータ$x$を生成するプロセスであるから、数式を用いて以下のように書ける。

$$z \sim p_{\theta}(z) \tag{2}$$
$$x = g_{\theta}(z) \tag{3}$$

$z$の確率分布は単純化して球面ガウス分布$\mathcal{N}(z; 0, I)$をとることが多い。また、生成プロセス$g_{\theta}(z)$はニューラルネットワークを用いて実装される。
ここで、変換$g_{\theta}$は可逆的である、すなわち逆変換$f_{\theta} = g_{\theta}^{-1}$が存在すると仮定する。以後の説明では表記を簡単にするためにパラメータ$\theta$の添字を省略する。

ニューラルネットワークのように多層からなる変換は、合成関数を用いて以下のように書ける。

$$f = f_1 \circ \cdots \circ f_2 \circ f_K$$

これを写像で表すと、

$$x \xleftrightarrow{f_1} h_1 \xleftrightarrow{f_2} h_2 \cdots \xleftrightarrow{f_K} z \tag{4}$$

となる。この一連の写像によるシーケンスを(normalizing) flowと呼ぶ。このフローは確率変数の変数変換を繰り返し適用したものであるから、対数尤度(1)は、

$$\begin{split}\log p(x) =& \log p(x) + \log | \det (dz/dx)| \\
=& \log p(x) + \sum_{i=1}^{K} \log | \det (dh_i/dh_{i-1})| \tag{6}
\end{split}$$

と書ける（$h_0 = x, h_K = z$とした）。この計算は複雑に見えるが、変換として、ヤコビアン$(dh_i/dh_{i-1})$が対角行列になるようなものを選択すると、以下のように非常に簡単に計算できる。

$$\det (dh_i/dh_{i-1})| = \mathrm{sum}(\log | \mathrm{diag} (dh_i/dh_{i-1}) |) \tag{7}$$

したがって、ニューラルネットワークを設計する際はなるべくヤコビアンが対角行列となるようにレイヤの構造を選択する。また、パラメータを用いて可逆的に変換が可能になるようなものを用いる。

学習時は上記の方法で計算した対数尤度を直接最大化する。また、生成時は潜在変数$z$を確率分布からランダムに抽出し、学習時と逆変換を適用することでデータ$x$を生成する。

## 提案手法で使用する可逆レイヤ

提案手法では以下の3つを使用する。

1. Actnorm
2. 可逆1x1 convolution
3. Affine coupling layer

### Actnorm

Batch Normの代用として使用。チャネルごとにアフィン変換（スケーリングとバイアスの加算）を行う。

### 可逆1x1 convolution

既存手法であるpermutation操作を一般化したもの。変換行列が可逆となるようにランダムな回転行列で初期化する。変換行列をLU分解することで$\mathcal{O}(c^3)$から$\mathcal{O}(c)$に計算量が削減できる（$c$はチャネル数）。

### Affine coupling layer

入力テンソルを2分割する。片方のテンソルには変換を適用せず、アフィン変換のパラメータの計算に用いる。パラメータは浅いニューラルネットワークで推定する。もう片方のテンソルには計算したパラメータを用いてアフィン変換を適用する。片方を不変にする理由は、逆変換を計算可能にするため[^1]。最終的に2つのテンソルを結合したものを出力する。

[^1]: 仮に入力値を変更してしまった場合、アフィン変換のパラメータが特定できず、逆変換を計算できない。

![](https://storage.googleapis.com/zenn-user-upload/9a08c2a8aa16-20220803.png)
